//@version=6
indicator("Lowkeigh-MTF_VWAP", shorttitle="Lowkeigh-MTF_VWAP", overlay=true, max_lines_count=500, max_labels_count=500)

// ── Timeframe ─────────────────────────────────────────────────────────────────
tf_mode = input.string("Auto", "Timeframe",
     options=["Auto", "Yearly", "Quarterly", "Monthly", "Weekly", "Daily"],
     group="Timeframe")

// ── Exchange Sources ───────────────────────────────────────────────────────────
// Dynamic Mode builds exchange symbols from the chart's base/quote currency
// automatically. Disable to use the manual symbol inputs below instead.
grp_src = "Exchange Sources"

use_dynamic  = input.bool(true,  "Auto-detect pair from chart (Dynamic Mode)",
     tooltip="When ON, exchange symbols are constructed automatically from the chart's base and quote currency (e.g. ETH + USDT → ETHUSDT on each exchange).\n\nWhen OFF, use the manual symbol inputs below. Useful when an exchange uses a non-standard ticker for a pair.",
     group=grp_src)

inp_binance  = input.symbol("BINANCE:BTCUSDT",  "Binance",  group=grp_src,
     tooltip="Used only when Dynamic Mode is OFF")
inp_bybit    = input.symbol("BYBIT:BTCUSDT",    "Bybit",    group=grp_src,
     tooltip="Used only when Dynamic Mode is OFF")
inp_coinbase = input.symbol("COINBASE:BTCUSD",  "Coinbase", group=grp_src,
     tooltip="Used only when Dynamic Mode is OFF.\nIn Dynamic Mode, Coinbase quote currency is auto-converted (USDT → USD)")
inp_kraken   = input.symbol("KRAKEN:XBTUSD",    "Kraken",   group=grp_src,
     tooltip="Used only when Dynamic Mode is OFF.\nIn Dynamic Mode, Kraken base currency is auto-converted (BTC → XBT) and quote (USDT → USD)")
inp_mexc     = input.symbol("MEXC:BTCUSDT",     "MEXC",     group=grp_src,
     tooltip="Used only when Dynamic Mode is OFF")
inp_okx      = input.symbol("OKX:BTCUSDT",      "OKX",      group=grp_src,
     tooltip="Used only when Dynamic Mode is OFF")
inp_kucoin   = input.symbol("KUCOIN:BTCUSDT",   "KuCoin",   group=grp_src,
     tooltip="Used only when Dynamic Mode is OFF")
inp_blofin   = input.symbol("BLOFIN:BTCUSDT",   "BloFin",   group=grp_src,
     tooltip="Used only when Dynamic Mode is OFF")
inp_bitget   = input.symbol("BITGET:BTCUSDT",   "Bitget",   group=grp_src,
     tooltip="Used only when Dynamic Mode is OFF")
inp_coinex   = input.symbol("COINEX:BTCUSDT",   "CoinEx",   group=grp_src,
     tooltip="Used only when Dynamic Mode is OFF")

// ── Exchange Toggles ───────────────────────────────────────────────────────────
grp_tog      = "Exchange Toggles"
use_binance  = input.bool(true, "Binance",  group=grp_tog)
use_bybit    = input.bool(true, "Bybit",    group=grp_tog)
use_coinbase = input.bool(true, "Coinbase", group=grp_tog)
use_kraken   = input.bool(true, "Kraken",   group=grp_tog)
use_mexc     = input.bool(true, "MEXC",     group=grp_tog)
use_okx      = input.bool(true, "OKX",      group=grp_tog)
use_kucoin   = input.bool(true, "KuCoin",   group=grp_tog)
use_blofin   = input.bool(true, "BloFin",   group=grp_tog)
use_bitget   = input.bool(true, "Bitget",   group=grp_tog)
use_coinex   = input.bool(true, "CoinEx",   group=grp_tog)

// ── Display ───────────────────────────────────────────────────────────────────
show_sd1   = input.bool(true,  "Show Value Area (±1 SD)",        group="Display")
show_sd2   = input.bool(false, "Show ±SD2 Bands",                group="Display")
sd2_mult   = input.float(2.0,  "SD2 Multiplier",  minval=0.1, step=0.1, group="Display",
     tooltip="Custom multiplier for SD band 2 (default 2.0)")
shade_sd2  = input.bool(false, "Shade ±SD2 Band",                group="Display")
show_sd3   = input.bool(false, "Show ±SD3 Bands",                group="Display")
sd3_mult   = input.float(3.0,  "SD3 Multiplier",  minval=0.1, step=0.1, group="Display",
     tooltip="Custom multiplier for SD band 3 (default 3.0)")
shade_sd3  = input.bool(false, "Shade ±SD3 Band",                group="Display")
show_prev  = input.bool(true,  "Show Previous Period",            group="Display")
shade_dev  = input.bool(true,  "Shade Developing Value Area",     group="Display")
shade_prev = input.bool(false, "Shade Previous Value Area",       group="Display")
show_lbl   = input.bool(true,  "Show Labels",                     group="Display")
show_ext   = input.bool(true,  "Extend Developing Lines to RHS",  group="Display")

// ── Rolling VWAP ──────────────────────────────────────────────────────────────
grp_rv     = "Rolling VWAP"
rv_show    = input.bool(false, "Enable Rolling VWAP",              group=grp_rv)
rv_days    = input.int(30,     "Duration (days)", minval=1,         group=grp_rv,
     tooltip="Number of calendar days to look back for the rolling VWAP.\nExamples: 18 days, 70 days, 365 days.\n\nNote: very large values on low timeframe charts may exceed Pine Script's maximum lookback limit.")
rv_show_sd = input.bool(false, "Show ±1 SD Bands (rvVAH / rvVAL)", group=grp_rv)
rv_shade   = input.bool(false, "Shade Rolling Value Area",          group=grp_rv)
c_rv_vwap  = input.color(color.new(#FF9800, 0),  "rvVWAP colour",  group=grp_rv)
c_rv_vah   = input.color(color.new(#FF5722, 0),  "rvVAH colour",   group=grp_rv)
c_rv_val   = input.color(color.new(#FF5722, 0),  "rvVAL colour",   group=grp_rv)
c_rv_fill  = input.color(color.new(#FF9800, 85), "rvVA Fill",      group=grp_rv)

// ── Colours: Developing ───────────────────────────────────────────────────────
c_vwap     = input.color(color.new(#2196F3, 0),  "VWAP",            group="Colours: Developing")
c_vah      = input.color(color.new(#4CAF50, 0),  "VAH",             group="Colours: Developing")
c_val      = input.color(color.new(#4CAF50, 0),  "VAL",             group="Colours: Developing")
c_sd2      = input.color(color.new(#FF9800, 20), "±SD2",            group="Colours: Developing")
c_fill_sd2 = input.color(color.new(#FF9800, 85), "SD2 Fill",        group="Colours: Developing")
c_sd3      = input.color(color.new(#F44336, 20), "±SD3",            group="Colours: Developing")
c_fill_sd3 = input.color(color.new(#F44336, 85), "SD3 Fill",        group="Colours: Developing")
c_fill_dev = input.color(color.new(#4CAF50, 85), "Value Area Fill", group="Colours: Developing")

// ── Colours: Previous ─────────────────────────────────────────────────────────
c_pvwap    = input.color(color.new(#9E9E9E, 30), "Prev VWAP",       group="Colours: Previous")
c_pvah     = input.color(color.new(#9E9E9E, 30), "Prev VAH",        group="Colours: Previous")
c_pval     = input.color(color.new(#9E9E9E, 30), "Prev VAL",        group="Colours: Previous")
c_fill_prv = input.color(color.new(#9E9E9E, 85), "Value Area Fill", group="Colours: Previous")

// ── Colours: Labels ───────────────────────────────────────────────────────────
c_lbl_d_bg = input.color(color.new(#2196F3, 10), "Dev Label BG",    group="Colours: Labels")
c_lbl_d_tx = input.color(color.white,             "Dev Label Text",  group="Colours: Labels")
c_lbl_p_bg = input.color(color.new(#9E9E9E, 10), "Prev Label BG",   group="Colours: Labels")
c_lbl_p_tx = input.color(color.white,             "Prev Label Text", group="Colours: Labels")

// ── Dynamic symbol construction ───────────────────────────────────────────────
_base  = syminfo.basecurrency
_quote = syminfo.currency

_cb_quote = str.replace(_quote, "USDT", "USD")
_kr_base  = _base == "BTC" ? "XBT" : _base
_kr_quote = str.replace(_quote, "USDT", "USD")

sym_binance  = use_dynamic ? "BINANCE:"  + _base    + _quote    : inp_binance
sym_bybit    = use_dynamic ? "BYBIT:"    + _base    + _quote    : inp_bybit
sym_coinbase = use_dynamic ? "COINBASE:" + _base    + _cb_quote : inp_coinbase
sym_kraken   = use_dynamic ? "KRAKEN:"   + _kr_base + _kr_quote : inp_kraken
sym_mexc     = use_dynamic ? "MEXC:"     + _base    + _quote    : inp_mexc
sym_okx      = use_dynamic ? "OKX:"      + _base    + _quote    : inp_okx
sym_kucoin   = use_dynamic ? "KUCOIN:"   + _base    + _quote    : inp_kucoin
sym_blofin   = use_dynamic ? "BLOFIN:"   + _base    + _quote    : inp_blofin
sym_bitget   = use_dynamic ? "BITGET:"   + _base    + _quote    : inp_bitget
sym_coinex   = use_dynamic ? "COINEX:"   + _base    + _quote    : inp_coinex

// ── Data fetching ─────────────────────────────────────────────────────────────
[tp_bnb, vol_bnb] = request.security(sym_binance,  timeframe.period, [hlc3, volume], ignore_invalid_symbol=true)
[tp_byb, vol_byb] = request.security(sym_bybit,    timeframe.period, [hlc3, volume], ignore_invalid_symbol=true)
[tp_cb,  vol_cb]  = request.security(sym_coinbase, timeframe.period, [hlc3, volume], ignore_invalid_symbol=true)
[tp_kr,  vol_kr]  = request.security(sym_kraken,   timeframe.period, [hlc3, volume], ignore_invalid_symbol=true)
[tp_mx,  vol_mx]  = request.security(sym_mexc,     timeframe.period, [hlc3, volume], ignore_invalid_symbol=true)
[tp_okx, vol_okx] = request.security(sym_okx,      timeframe.period, [hlc3, volume], ignore_invalid_symbol=true)
[tp_kuc, vol_kuc] = request.security(sym_kucoin,   timeframe.period, [hlc3, volume], ignore_invalid_symbol=true)
[tp_blf, vol_blf] = request.security(sym_blofin,   timeframe.period, [hlc3, volume], ignore_invalid_symbol=true)
[tp_btg, vol_btg] = request.security(sym_bitget,   timeframe.period, [hlc3, volume], ignore_invalid_symbol=true)
[tp_cex, vol_cex] = request.security(sym_coinex,   timeframe.period, [hlc3, volume], ignore_invalid_symbol=true)

// ── Per-bar aggregation helpers ───────────────────────────────────────────────
f_vol(ena, v)     => ena and not na(v) ? nz(v) : 0.0
f_tpv(ena, t, v)  => ena and not na(v) ? nz(t) * nz(v) : 0.0
f_tp2v(ena, t, v) => ena and not na(v) ? nz(t) * nz(t) * nz(v) : 0.0

agg_vol  = f_vol (use_binance,  vol_bnb)           + f_vol (use_bybit,    vol_byb)           +
           f_vol (use_coinbase, vol_cb)             + f_vol (use_kraken,   vol_kr)            +
           f_vol (use_mexc,     vol_mx)             + f_vol (use_okx,      vol_okx)           +
           f_vol (use_kucoin,   vol_kuc)            + f_vol (use_blofin,   vol_blf)           +
           f_vol (use_bitget,   vol_btg)            + f_vol (use_coinex,   vol_cex)

agg_tpv  = f_tpv (use_binance,  tp_bnb, vol_bnb)   + f_tpv (use_bybit,    tp_byb, vol_byb)   +
           f_tpv (use_coinbase, tp_cb,  vol_cb)     + f_tpv (use_kraken,   tp_kr,  vol_kr)    +
           f_tpv (use_mexc,     tp_mx,  vol_mx)     + f_tpv (use_okx,      tp_okx, vol_okx)   +
           f_tpv (use_kucoin,   tp_kuc, vol_kuc)    + f_tpv (use_blofin,   tp_blf, vol_blf)   +
           f_tpv (use_bitget,   tp_btg, vol_btg)    + f_tpv (use_coinex,   tp_cex, vol_cex)

agg_tp2v = f_tp2v(use_binance,  tp_bnb, vol_bnb)   + f_tp2v(use_bybit,    tp_byb, vol_byb)   +
           f_tp2v(use_coinbase, tp_cb,  vol_cb)     + f_tp2v(use_kraken,   tp_kr,  vol_kr)    +
           f_tp2v(use_mexc,     tp_mx,  vol_mx)     + f_tp2v(use_okx,      tp_okx, vol_okx)   +
           f_tp2v(use_kucoin,   tp_kuc, vol_kuc)    + f_tp2v(use_blofin,   tp_blf, vol_blf)   +
           f_tp2v(use_bitget,   tp_btg, vol_btg)    + f_tp2v(use_coinex,   tp_cex, vol_cex)

// ── Effective timeframe ───────────────────────────────────────────────────────
tf_secs = timeframe.in_seconds()

eff_tf = tf_mode != "Auto" ? tf_mode :
         tf_secs >= 86400  ? "Yearly" :
         tf_secs >  14400  ? "Quarterly" :
         tf_secs >= 3600   ? "Monthly" :
         tf_secs >= 1800   ? "Weekly" : "Daily"

// ── Period detection ──────────────────────────────────────────────────────────
cur_q  = month(time) <= 3 ? 1 : month(time) <= 6 ? 2 : month(time) <= 9 ? 3 : 4
prev_q = barstate.isfirst ? 0 : (month(time[1]) <= 3 ? 1 : month(time[1]) <= 6 ? 2 : month(time[1]) <= 9 ? 3 : 4)

new_year  = barstate.isfirst ? true : year(time)       != year(time[1])
new_qtr   = new_year         ? true : cur_q            != prev_q
new_month = new_qtr          ? true : month(time)      != (barstate.isfirst ? -1 : month(time[1]))
new_week  = new_month        ? true : weekofyear(time) != (barstate.isfirst ? -1 : weekofyear(time[1]))
new_day   = new_week         ? true : dayofmonth(time) != (barstate.isfirst ? -1 : dayofmonth(time[1]))

new_period = eff_tf == "Yearly"    ? new_year  :
             eff_tf == "Quarterly" ? new_qtr   :
             eff_tf == "Monthly"   ? new_month :
             eff_tf == "Weekly"    ? new_week  : new_day

// ── VWAP computation (using aggregated cross-exchange data) ───────────────────
var float cum_tpv  = 0.0
var float cum_vol  = 0.0
var float cum_tp2v = 0.0
var float prev_vwap = na
var float prev_sd   = na

if new_period
    if cum_vol > 0.0
        float _pv  = cum_tpv / cum_vol
        float _var = math.max(cum_tp2v / cum_vol - _pv * _pv, 0.0)
        prev_vwap := _pv
        prev_sd   := math.sqrt(_var)
    cum_tpv  := agg_tpv
    cum_vol  := agg_vol
    cum_tp2v := agg_tp2v
else
    cum_tpv  += agg_tpv
    cum_vol  += agg_vol
    cum_tp2v += agg_tp2v

vwap     = cum_vol > 0.0 ? cum_tpv / cum_vol : na
_raw_var = cum_vol > 0.0 ? math.max(cum_tp2v / cum_vol - vwap * vwap, 0.0) : na
sd       = not na(_raw_var) ? math.sqrt(_raw_var) : na

vhi  = not na(sd) ? vwap + sd            : na
vlo  = not na(sd) ? vwap - sd            : na
vhi2 = not na(sd) ? vwap + sd2_mult * sd : na
vlo2 = not na(sd) ? vwap - sd2_mult * sd : na
vhi3 = not na(sd) ? vwap + sd3_mult * sd : na
vlo3 = not na(sd) ? vwap - sd3_mult * sd : na

pvhi = not na(prev_sd) ? prev_vwap + prev_sd : na
pvlo = not na(prev_sd) ? prev_vwap - prev_sd : na

// ── Rolling VWAP computation ──────────────────────────────────────────────────
// Converts the day duration into a bar count, then sums using a rolling window.
// Uses the same aggregated cross-exchange data as the main VWAP.
rv_bars     = math.max(1, math.round(rv_days * 86400 / tf_secs))
rv_sum_vol  = math.sum(agg_vol,  rv_bars)
rv_sum_tpv  = math.sum(agg_tpv,  rv_bars)
rv_sum_tp2v = math.sum(agg_tp2v, rv_bars)

rv_vwap    = rv_show and rv_sum_vol > 0.0 ? rv_sum_tpv / rv_sum_vol : na
_rv_var    = rv_show and rv_sum_vol > 0.0 ? math.max(rv_sum_tp2v / rv_sum_vol - (rv_sum_tpv / rv_sum_vol) * (rv_sum_tpv / rv_sum_vol), 0.0) : na
rv_sd      = not na(_rv_var) ? math.sqrt(_rv_var) : na
rv_vah     = rv_show and rv_show_sd and not na(rv_sd) ? rv_vwap + rv_sd : na
rv_val     = rv_show and rv_show_sd and not na(rv_sd) ? rv_vwap - rv_sd : na

// ── Plots ─────────────────────────────────────────────────────────────────────
p_vwap  = plot(vwap,                  "VWAP",    c_vwap, 2)
p_vhi   = plot(show_sd1 ? vhi  : na, "VAH",     c_vah,  1)
p_vlo   = plot(show_sd1 ? vlo  : na, "VAL",     c_val,  1)
p_vhi2  = plot(show_sd2 ? vhi2 : na, "VAH+SD2", c_sd2,  1)
p_vlo2  = plot(show_sd2 ? vlo2 : na, "VAL-SD2", c_sd2,  1)
p_vhi3  = plot(show_sd3 ? vhi3 : na, "VAH+SD3", c_sd3,  1)
p_vlo3  = plot(show_sd3 ? vlo3 : na, "VAL-SD3", c_sd3,  1)

p_pvwap = plot(show_prev ? prev_vwap : na, "P.VWAP", c_pvwap, 1, plot.style_linebr)
p_pvhi  = plot(show_prev ? pvhi      : na, "P.VAH",  c_pvah,  1, plot.style_linebr)
p_pvlo  = plot(show_prev ? pvlo      : na, "P.VAL",  c_pval,  1, plot.style_linebr)

p_rv_vwap = plot(rv_vwap, "rvVWAP", c_rv_vwap, 2)
p_rv_vah  = plot(rv_vah,  "rvVAH",  c_rv_vah,  1)
p_rv_val  = plot(rv_val,  "rvVAL",  c_rv_val,  1)

// ── Fills ─────────────────────────────────────────────────────────────────────
fill(p_vhi,    p_vlo,    shade_dev  and show_sd1               ? c_fill_dev : na)
fill(p_pvhi,   p_pvlo,   shade_prev and show_prev              ? c_fill_prv : na)
fill(p_vhi2,   p_vlo2,   shade_sd2  and show_sd2               ? c_fill_sd2 : na)
fill(p_vhi3,   p_vlo3,   shade_sd3  and show_sd3               ? c_fill_sd3 : na)
fill(p_rv_vah, p_rv_val, rv_shade   and rv_show and rv_show_sd ? c_rv_fill  : na)

// ── Extension lines ───────────────────────────────────────────────────────────
var line ext_vwap_ln    = na
var line ext_vhi_ln     = na
var line ext_vlo_ln     = na
var line ext_pvwap_ln   = na
var line ext_pvah_ln    = na
var line ext_pval_ln    = na
var line ext_rv_vwap_ln = na
var line ext_rv_vah_ln  = na
var line ext_rv_val_ln  = na

if show_ext
    if new_period
        if not na(ext_vwap_ln)
            line.delete(ext_vwap_ln)
        if not na(ext_vhi_ln)
            line.delete(ext_vhi_ln)
        if not na(ext_vlo_ln)
            line.delete(ext_vlo_ln)
        if not na(vwap)
            ext_vwap_ln := line.new(bar_index, vwap, bar_index + 1, vwap,
                 extend=extend.right, style=line.style_dashed, color=c_vwap, width=1)
        if not na(vhi)
            ext_vhi_ln := line.new(bar_index, vhi, bar_index + 1, vhi,
                 extend=extend.right, style=line.style_dashed, color=c_vah, width=1)
        if not na(vlo)
            ext_vlo_ln := line.new(bar_index, vlo, bar_index + 1, vlo,
                 extend=extend.right, style=line.style_dashed, color=c_val, width=1)
    else
        if not na(ext_vwap_ln) and not na(vwap)
            line.set_x1(ext_vwap_ln, bar_index)
            line.set_x2(ext_vwap_ln, bar_index + 1)
            line.set_y1(ext_vwap_ln, vwap)
            line.set_y2(ext_vwap_ln, vwap)
        if not na(ext_vhi_ln) and not na(vhi)
            line.set_x1(ext_vhi_ln, bar_index)
            line.set_x2(ext_vhi_ln, bar_index + 1)
            line.set_y1(ext_vhi_ln, vhi)
            line.set_y2(ext_vhi_ln, vhi)
        if not na(ext_vlo_ln) and not na(vlo)
            line.set_x1(ext_vlo_ln, bar_index)
            line.set_x2(ext_vlo_ln, bar_index + 1)
            line.set_y1(ext_vlo_ln, vlo)
            line.set_y2(ext_vlo_ln, vlo)

if show_prev and barstate.islast
    line.delete(ext_pvwap_ln)
    line.delete(ext_pvah_ln)
    line.delete(ext_pval_ln)
    if not na(prev_vwap)
        ext_pvwap_ln := line.new(bar_index, prev_vwap, bar_index + 1, prev_vwap,
             extend=extend.right, style=line.style_dashed, color=c_pvwap, width=1)
    if not na(pvhi)
        ext_pvah_ln := line.new(bar_index, pvhi, bar_index + 1, pvhi,
             extend=extend.right, style=line.style_dashed, color=c_pvah, width=1)
    if not na(pvlo)
        ext_pval_ln := line.new(bar_index, pvlo, bar_index + 1, pvlo,
             extend=extend.right, style=line.style_dashed, color=c_pval, width=1)

if rv_show and barstate.islast
    line.delete(ext_rv_vwap_ln)
    line.delete(ext_rv_vah_ln)
    line.delete(ext_rv_val_ln)
    if not na(rv_vwap)
        ext_rv_vwap_ln := line.new(bar_index, rv_vwap, bar_index + 1, rv_vwap,
             extend=extend.right, style=line.style_dashed, color=c_rv_vwap, width=1)
    if not na(rv_vah)
        ext_rv_vah_ln := line.new(bar_index, rv_vah, bar_index + 1, rv_vah,
             extend=extend.right, style=line.style_dashed, color=c_rv_vah, width=1)
    if not na(rv_val)
        ext_rv_val_ln := line.new(bar_index, rv_val, bar_index + 1, rv_val,
             extend=extend.right, style=line.style_dashed, color=c_rv_val, width=1)

// ── Label prefixes based on effective timeframe ───────────────────────────────
d_pfx = switch eff_tf
    "Yearly"    => "dy"
    "Quarterly" => "dq"
    "Monthly"   => "dm"
    "Weekly"    => "dw"
    => "dd"

p_pfx = switch eff_tf
    "Yearly"    => "py"
    "Quarterly" => "pq"
    "Monthly"   => "pm"
    "Weekly"    => "pw"
    => "pd"

// ── Labels ────────────────────────────────────────────────────────────────────
var label lbl_dvwap   = na
var label lbl_dvah    = na
var label lbl_dval    = na
var label lbl_pvwap   = na
var label lbl_pvah    = na
var label lbl_pval    = na
var label lbl_rv_vwap = na
var label lbl_rv_vah  = na
var label lbl_rv_val  = na

if show_lbl and barstate.islast
    vis_range = chart.right_visible_bar_time - chart.left_visible_bar_time
    dev_x = time + int(vis_range * 0.10)
    prv_x = time + int(vis_range * 0.20)
    rv_x  = time + int(vis_range * 0.15)

    label.delete(lbl_dvwap)
    label.delete(lbl_dvah)
    label.delete(lbl_dval)

    if not na(vwap)
        lbl_dvwap := label.new(dev_x, vwap,
             d_pfx + "VWAP " + str.tostring(vwap, format.mintick),
             xloc=xloc.bar_time, style=label.style_label_left,
             color=c_lbl_d_bg, textcolor=c_lbl_d_tx, size=size.small)
    if not na(vhi)
        lbl_dvah := label.new(dev_x, vhi,
             d_pfx + "VAH " + str.tostring(vhi, format.mintick),
             xloc=xloc.bar_time, style=label.style_label_left,
             color=c_lbl_d_bg, textcolor=c_lbl_d_tx, size=size.small)
    if not na(vlo)
        lbl_dval := label.new(dev_x, vlo,
             d_pfx + "VAL " + str.tostring(vlo, format.mintick),
             xloc=xloc.bar_time, style=label.style_label_left,
             color=c_lbl_d_bg, textcolor=c_lbl_d_tx, size=size.small)

    if show_prev
        label.delete(lbl_pvwap)
        label.delete(lbl_pvah)
        label.delete(lbl_pval)

        if not na(prev_vwap)
            lbl_pvwap := label.new(prv_x, prev_vwap,
                 p_pfx + "VWAP " + str.tostring(prev_vwap, format.mintick),
                 xloc=xloc.bar_time, style=label.style_label_left,
                 color=c_lbl_p_bg, textcolor=c_lbl_p_tx, size=size.small)
        if not na(pvhi)
            lbl_pvah := label.new(prv_x, pvhi,
                 p_pfx + "VAH " + str.tostring(pvhi, format.mintick),
                 xloc=xloc.bar_time, style=label.style_label_left,
                 color=c_lbl_p_bg, textcolor=c_lbl_p_tx, size=size.small)
        if not na(pvlo)
            lbl_pval := label.new(prv_x, pvlo,
                 p_pfx + "VAL " + str.tostring(pvlo, format.mintick),
                 xloc=xloc.bar_time, style=label.style_label_left,
                 color=c_lbl_p_bg, textcolor=c_lbl_p_tx, size=size.small)

    if rv_show
        label.delete(lbl_rv_vwap)
        label.delete(lbl_rv_vah)
        label.delete(lbl_rv_val)

        if not na(rv_vwap)
            lbl_rv_vwap := label.new(rv_x, rv_vwap,
                 "rvVWAP(" + str.tostring(rv_days) + "d) " + str.tostring(rv_vwap, format.mintick),
                 xloc=xloc.bar_time, style=label.style_label_left,
                 color=color.new(c_rv_vwap, 10), textcolor=color.white, size=size.small)
        if not na(rv_vah)
            lbl_rv_vah := label.new(rv_x, rv_vah,
                 "rvVAH(" + str.tostring(rv_days) + "d) " + str.tostring(rv_vah, format.mintick),
                 xloc=xloc.bar_time, style=label.style_label_left,
                 color=color.new(c_rv_vah, 10), textcolor=color.white, size=size.small)
        if not na(rv_val)
            lbl_rv_val := label.new(rv_x, rv_val,
                 "rvVAL(" + str.tostring(rv_days) + "d) " + str.tostring(rv_val, format.mintick),
                 xloc=xloc.bar_time, style=label.style_label_left,
                 color=color.new(c_rv_val, 10), textcolor=color.white, size=size.small)

// ── Alerts ────────────────────────────────────────────────────────────────────
alertcondition(ta.cross(close, vwap),      "Price x VWAP",      "Price crossed Agg-VWAP")
alertcondition(ta.cross(close, vhi),       "Price x VAH",       "Price crossed Agg-VAH (+1 SD)")
alertcondition(ta.cross(close, vlo),       "Price x VAL",       "Price crossed Agg-VAL (-1 SD)")
alertcondition(ta.cross(close, prev_vwap), "Price x Prev VWAP", "Price crossed Previous Agg-VWAP")
alertcondition(ta.cross(close, rv_vwap),   "Price x rvVWAP",    "Price crossed Rolling VWAP")
alertcondition(ta.cross(close, rv_vah),    "Price x rvVAH",     "Price crossed Rolling VAH (+1 SD)")
alertcondition(ta.cross(close, rv_val),    "Price x rvVAL",     "Price crossed Rolling VAL (-1 SD)")
