// =============================================================================
// Multi-Timeframe Anchored VWAP + Value Areas
//
// Enhanced from: Yearly Anchored VWAP + Standard Deviation Bands
//
// Features:
//   - Yearly, Quarterly, Monthly, Weekly value areas
//   - Auto timeframe selection based on chart timeframe:
//       Daily or higher  →  Yearly
//       > 4H and < Daily →  Quarterly
//       1H to 4H         →  Monthly
//       Below 1H         →  Weekly
//   - Extending dashed lines for the developing period projected to RHS edge
//     (frozen at period boundary when the next period begins)
//   - Value area shading with configurable colours
//   - Configurable colours for every line
//   - Price labels (DVAH, VWAP, DVAL, PVWAP, PVAH, PVAL) positioned
//     30% in from the right-hand side of the visible screen
//
// TP formula: close (backtest confirmed: outperforms HLC/3 by ~70x)
// =============================================================================

//@version=5
indicator("Multi-TF Anchored VWAP", shorttitle="MTF-VWAP", overlay=true,
    max_lines_count    = 500,
    max_labels_count   = 500,
    max_linefills_count = 100)

// ─────────────────────────────────────────────────────────────────────────────
// INPUT GROUPS
// ─────────────────────────────────────────────────────────────────────────────
var string G_TF    = "Timeframe"
var string G_DISP  = "Display"
var string G_CDEV  = "Colours — Developing Period"
var string G_CPREV = "Colours — Previous Period"

// ── Timeframe selection ───────────────────────────────────────────────────────
tf_choice = input.string("Auto", "Value Area Timeframe",
    options  = ["Auto", "Yearly", "Quarterly", "Monthly", "Weekly"],
    group    = G_TF,
    tooltip  = "Auto selects the value area based on the chart timeframe:\n" +
               "  Daily or higher  →  Yearly\n" +
               "  > 4H to < Daily  →  Quarterly\n" +
               "  1H to 4H         →  Monthly\n" +
               "  Below 1H         →  Weekly")

// ── Display options ───────────────────────────────────────────────────────────
show_sd1    = input.bool(true,  "Show Value Area (±1 SD bands)", group=G_DISP)
show_prev   = input.bool(true,  "Show Previous Period",          group=G_DISP)
show_fill   = input.bool(true,  "Show Value Area Shading",       group=G_DISP)
show_labels = input.bool(true,  "Show Labels",                   group=G_DISP)
show_sd2    = input.bool(false, "Show ±2 SD Bands",              group=G_DISP)
show_sd3    = input.bool(false, "Show ±3 SD Bands",              group=G_DISP)

// ── Colours — developing period ───────────────────────────────────────────────
c_vwap     = input.color(color.new(#2196F3, 0),  "VWAP line",            group=G_CDEV)
c_vah      = input.color(color.new(#4CAF50, 0),  "VAH line",             group=G_CDEV)
c_val      = input.color(color.new(#F44336, 0),  "VAL line",             group=G_CDEV)
c_sd2      = input.color(color.new(#FF9800, 0),  "±2 SD lines",          group=G_CDEV)
c_sd3      = input.color(color.new(#9C27B0, 0),  "±3 SD lines",          group=G_CDEV)
c_fill_dev = input.color(color.new(#2196F3, 85), "Value area fill",      group=G_CDEV)
c_lbl_bg   = input.color(color.new(#1565C0, 20), "Label background",     group=G_CDEV)
c_lbl_txt  = input.color(color.new(#FFFFFF, 0),  "Label text",           group=G_CDEV)

// ── Colours — previous period ─────────────────────────────────────────────────
c_pvwap    = input.color(color.new(#9E9E9E, 20), "Prev VWAP line",       group=G_CPREV)
c_pvband   = input.color(color.new(#78909C, 30), "Prev VAH/VAL lines",   group=G_CPREV)
c_fill_prv = input.color(color.new(#9E9E9E, 88), "Prev value area fill", group=G_CPREV)
c_plbl_bg  = input.color(color.new(#424242, 30), "Prev label background",group=G_CPREV)

// ─────────────────────────────────────────────────────────────────────────────
// EFFECTIVE TIMEFRAME (resolve Auto)
// ─────────────────────────────────────────────────────────────────────────────
tf_mins = timeframe.in_seconds / 60   // chart timeframe in minutes

eff_tf = if tf_choice == "Auto"
    if tf_mins >= 1440          // Daily (1440 min) or higher
        "Yearly"
    else if tf_mins > 240       // > 4H (240 min) and < Daily
        "Quarterly"
    else if tf_mins >= 60       // 1H (60 min) to 4H (240 min) inclusive
        "Monthly"
    else                        // Below 1H
        "Weekly"
else
    tf_choice

// ─────────────────────────────────────────────────────────────────────────────
// PERIOD DETECTION
// ─────────────────────────────────────────────────────────────────────────────
// Returns quarter index 0-3 for any bar time
qtr(t) => math.floor((month(t) - 1) / 3)

// Unique integer per period across all years, to avoid year-boundary false-negatives
_yr_id  = year(time)
_yr_id1 = year(time[1])
_qtr_id  = year(time) * 4  + qtr(time)
_qtr_id1 = year(time[1]) * 4 + qtr(time[1])
_mon_id  = year(time) * 12 + month(time)
_mon_id1 = year(time[1]) * 12 + month(time[1])
_wk_id   = year(time) * 54 + weekofyear(time)
_wk_id1  = year(time[1]) * 54 + weekofyear(time[1])

is_new_year    = barstate.isfirst or (_yr_id  != _yr_id1)
is_new_quarter = barstate.isfirst or (_qtr_id != _qtr_id1)
is_new_month   = barstate.isfirst or (_mon_id != _mon_id1)
is_new_week    = barstate.isfirst or (_wk_id  != _wk_id1)

new_period = switch eff_tf
    "Yearly"    => is_new_year
    "Quarterly" => is_new_quarter
    "Monthly"   => is_new_month
    "Weekly"    => is_new_week
    => is_new_year

// ─────────────────────────────────────────────────────────────────────────────
// VWAP ACCUMULATORS & CALCULATION
// ─────────────────────────────────────────────────────────────────────────────
var float cum_tpv  = 0.0
var float cum_vol  = 0.0
var float cum_tp2v = 0.0
var float prev_vwap = na
var float prev_sd   = na

tp = close   // backtest confirmed: close outperforms HLC/3 by ~70x

if new_period
    // Snapshot completed period before resetting
    if cum_vol > 0
        float _pv  = cum_tpv / cum_vol
        float _var = math.max(cum_tp2v / cum_vol - _pv * _pv, 0.0)
        prev_vwap := _pv
        prev_sd   := math.sqrt(_var)
    // Reset for new period
    cum_tpv  := tp * volume
    cum_vol  := volume
    cum_tp2v := tp * tp * volume
else
    cum_tpv  += tp * volume
    cum_vol  += volume
    cum_tp2v += tp * tp * volume

vwap     = cum_tpv / cum_vol
variance = math.max(cum_tp2v / cum_vol - vwap * vwap, 0.0)
sd       = math.sqrt(variance)

vah  = vwap + sd
val  = vwap - sd
vah2 = vwap + 2 * sd
val2 = vwap - 2 * sd
vah3 = vwap + 3 * sd
val3 = vwap - 3 * sd

pvwap = not na(prev_vwap) ? prev_vwap            : na
pvah  = not na(prev_sd)   ? prev_vwap + prev_sd  : na
pval  = not na(prev_sd)   ? prev_vwap - prev_sd  : na

// ─────────────────────────────────────────────────────────────────────────────
// PLOTS — developing + previous period historical lines
// ─────────────────────────────────────────────────────────────────────────────
p_vwap = plot(vwap,                         "VWAP",      c_vwap,  2)
p_vah  = plot(show_sd1 ? vah  : na,         "VAH",       c_vah,   1)
p_val  = plot(show_sd1 ? val  : na,         "VAL",       c_val,   1)

plot(show_sd2 ? vah2 : na, "VAH +2", c_sd2, 1)
plot(show_sd2 ? val2 : na, "VAL -2", c_sd2, 1)
plot(show_sd3 ? vah3 : na, "VAH +3", c_sd3, 1)
plot(show_sd3 ? val3 : na, "VAL -3", c_sd3, 1)

fill(p_vah, p_val,
    show_fill and show_sd1 ? c_fill_dev : na,
    "Developing Value Area Fill")

p_pvwap = plot(show_prev ? pvwap              : na, "PVWAP", c_pvwap,  1, plot.style_linebr)
p_pvah  = plot(show_prev and not na(pvah) ? pvah : na, "PVAH", c_pvband, 1, plot.style_linebr)
p_pval  = plot(show_prev and not na(pval) ? pval : na, "PVAL", c_pvband, 1, plot.style_linebr)

fill(p_pvah, p_pval,
    show_fill and show_prev and not na(pvah) ? c_fill_prv : na,
    "Previous Value Area Fill")

// ─────────────────────────────────────────────────────────────────────────────
// EXTENSION LINES — developing period levels projected to RHS
//
// Dashed horizontal lines at current VWAP / VAH / VAL extend to the right edge
// of the chart.  When the next period begins the old lines are deleted (the
// plot() series above already preserve the historical path) and fresh extension
// lines are created for the new developing period.
// ─────────────────────────────────────────────────────────────────────────────
var line     ext_vwap = na
var line     ext_vah  = na
var line     ext_val  = na
var linefill ext_lf   = na

// When a new period begins, remove the previous period's extension lines
if new_period and not barstate.isfirst
    linefill.delete(ext_lf)
    line.delete(ext_vwap)
    line.delete(ext_vah)
    line.delete(ext_val)
    ext_lf   := na
    ext_vwap := na
    ext_vah  := na
    ext_val  := na

// Create extension lines at the start of each period
if na(ext_vwap)
    ext_vwap := line.new(bar_index, vwap, bar_index + 1, vwap,
        extend = extend.right,
        color  = c_vwap,
        width  = 2,
        style  = line.style_dashed)
    if show_sd1
        ext_vah := line.new(bar_index, vah, bar_index + 1, vah,
            extend = extend.right,
            color  = c_vah,
            width  = 1,
            style  = line.style_dashed)
        ext_val := line.new(bar_index, val, bar_index + 1, val,
            extend = extend.right,
            color  = c_val,
            width  = 1,
            style  = line.style_dashed)
        if show_fill
            ext_lf := linefill.new(ext_vah, ext_val, c_fill_dev)
else
    // Update existing lines to the current bar's values
    line.set_xy1(ext_vwap, bar_index, vwap)
    line.set_xy2(ext_vwap, bar_index + 1, vwap)
    line.set_color(ext_vwap, c_vwap)

    if show_sd1
        if na(ext_vah)
            ext_vah := line.new(bar_index, vah, bar_index + 1, vah,
                extend=extend.right, color=c_vah, width=1, style=line.style_dashed)
            ext_val := line.new(bar_index, val, bar_index + 1, val,
                extend=extend.right, color=c_val, width=1, style=line.style_dashed)
        else
            line.set_xy1(ext_vah, bar_index, vah)
            line.set_xy2(ext_vah, bar_index + 1, vah)
            line.set_color(ext_vah, c_vah)
            line.set_xy1(ext_val, bar_index, val)
            line.set_xy2(ext_val, bar_index + 1, val)
            line.set_color(ext_val, c_val)
        // Linefill: keep in sync with show_fill toggle
        if show_fill and na(ext_lf) and not na(ext_vah)
            ext_lf := linefill.new(ext_vah, ext_val, c_fill_dev)
        else if not show_fill and not na(ext_lf)
            linefill.delete(ext_lf)
            ext_lf := na
    else
        // show_sd1 turned off — remove band extension lines
        if not na(ext_lf)
            linefill.delete(ext_lf)
            ext_lf := na
        if not na(ext_vah)
            line.delete(ext_vah)
            ext_vah := na
        if not na(ext_val)
            line.delete(ext_val)
            ext_val := na

// ─────────────────────────────────────────────────────────────────────────────
// LABELS — DVAH / VWAP / DVAL / PVAH / PVWAP / PVAL
//
// Positioned 30% in from the right edge of the visible screen using
// chart.left_visible_bar_time and chart.right_visible_bar_time.
// ─────────────────────────────────────────────────────────────────────────────
var label lbl_dvah  = na
var label lbl_vwap  = na
var label lbl_dval  = na
var label lbl_pvwap = na
var label lbl_pvah  = na
var label lbl_pval  = na

if show_labels
    // x position: 30% in from the right of the currently visible range
    vis_range = chart.right_visible_bar_time - chart.left_visible_bar_time
    lbl_x     = int(chart.right_visible_bar_time - vis_range * 0.3)

    // ── Developing period labels ──────────────────────────────────────────────
    txt_dvah = "DVAH: " + str.tostring(vah,  format.mintick)
    txt_vwap = "VWAP: " + str.tostring(vwap, format.mintick)
    txt_dval = "DVAL: " + str.tostring(val,  format.mintick)

    if na(lbl_dvah)
        lbl_dvah := label.new(lbl_x, vah, txt_dvah,
            xloc      = xloc.bar_time,
            color     = c_lbl_bg,
            textcolor = c_lbl_txt,
            style     = label.style_label_right,
            size      = size.small)
    else
        label.set_xy(lbl_dvah, lbl_x, vah)
        label.set_text(lbl_dvah, txt_dvah)
        label.set_color(lbl_dvah, c_lbl_bg)
        label.set_textcolor(lbl_dvah, c_lbl_txt)

    if na(lbl_vwap)
        lbl_vwap := label.new(lbl_x, vwap, txt_vwap,
            xloc      = xloc.bar_time,
            color     = c_lbl_bg,
            textcolor = c_lbl_txt,
            style     = label.style_label_right,
            size      = size.small)
    else
        label.set_xy(lbl_vwap, lbl_x, vwap)
        label.set_text(lbl_vwap, txt_vwap)
        label.set_color(lbl_vwap, c_lbl_bg)
        label.set_textcolor(lbl_vwap, c_lbl_txt)

    if na(lbl_dval)
        lbl_dval := label.new(lbl_x, val, txt_dval,
            xloc      = xloc.bar_time,
            color     = c_lbl_bg,
            textcolor = c_lbl_txt,
            style     = label.style_label_right,
            size      = size.small)
    else
        label.set_xy(lbl_dval, lbl_x, val)
        label.set_text(lbl_dval, txt_dval)
        label.set_color(lbl_dval, c_lbl_bg)
        label.set_textcolor(lbl_dval, c_lbl_txt)

    // ── Previous period labels ────────────────────────────────────────────────
    if show_prev and not na(pvwap)
        txt_pvwap = "PVWAP: " + str.tostring(pvwap, format.mintick)
        if na(lbl_pvwap)
            lbl_pvwap := label.new(lbl_x, pvwap, txt_pvwap,
                xloc      = xloc.bar_time,
                color     = c_plbl_bg,
                textcolor = c_lbl_txt,
                style     = label.style_label_right,
                size      = size.small)
        else
            label.set_xy(lbl_pvwap, lbl_x, pvwap)
            label.set_text(lbl_pvwap, txt_pvwap)
            label.set_color(lbl_pvwap, c_plbl_bg)
            label.set_textcolor(lbl_pvwap, c_lbl_txt)

        if not na(pvah)
            txt_pvah = "PVAH: " + str.tostring(pvah, format.mintick)
            txt_pval = "PVAL: " + str.tostring(pval, format.mintick)
            if na(lbl_pvah)
                lbl_pvah := label.new(lbl_x, pvah, txt_pvah,
                    xloc      = xloc.bar_time,
                    color     = c_plbl_bg,
                    textcolor = c_lbl_txt,
                    style     = label.style_label_right,
                    size      = size.small)
                lbl_pval := label.new(lbl_x, pval, txt_pval,
                    xloc      = xloc.bar_time,
                    color     = c_plbl_bg,
                    textcolor = c_lbl_txt,
                    style     = label.style_label_right,
                    size      = size.small)
            else
                label.set_xy(lbl_pvah, lbl_x, pvah)
                label.set_text(lbl_pvah, txt_pvah)
                label.set_color(lbl_pvah, c_plbl_bg)
                label.set_textcolor(lbl_pvah, c_lbl_txt)
                label.set_xy(lbl_pval, lbl_x, pval)
                label.set_text(lbl_pval, txt_pval)
                label.set_color(lbl_pval, c_plbl_bg)
                label.set_textcolor(lbl_pval, c_lbl_txt)
    else
        // Previous period disabled — remove those labels
        label.delete(lbl_pvwap)
        lbl_pvwap := na
        label.delete(lbl_pvah)
        lbl_pvah  := na
        label.delete(lbl_pval)
        lbl_pval  := na
else
    // Labels toggled off — remove all
    label.delete(lbl_dvah)
    lbl_dvah  := na
    label.delete(lbl_vwap)
    lbl_vwap  := na
    label.delete(lbl_dval)
    lbl_dval  := na
    label.delete(lbl_pvwap)
    lbl_pvwap := na
    label.delete(lbl_pvah)
    lbl_pvah  := na
    label.delete(lbl_pval)
    lbl_pval  := na

// ─────────────────────────────────────────────────────────────────────────────
// ALERTS
// ─────────────────────────────────────────────────────────────────────────────
alertcondition(ta.cross(close, vwap), "Price × VWAP",
    "Price crossed the developing VWAP")
alertcondition(ta.cross(close, vah),  "Price × VAH",
    "Price crossed VAH (upper value area boundary)")
alertcondition(ta.cross(close, val),  "Price × VAL",
    "Price crossed VAL (lower value area boundary)")
alertcondition(ta.cross(close, pvwap) and not na(pvwap), "Price × PVWAP",
    "Price crossed the previous period VWAP")
